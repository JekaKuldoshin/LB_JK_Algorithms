#include "List.h"

bool deque::check() {        //\\//\\ Функ-я проверки на наличие элементов очереди //\\//\\ 
	if (left == NULL) {        //Если пуст дэк, то выводим...
		system("cls");
		cout << "Ошибка! Очередь отсутствует!!!\n\nНажмите на Enter чтобы продолжить...";
		_getch();
		return false;
	}
	else
		return true;     //Если возврашает True, то мы можем пользоваться всем функционалом программы
}

void deque::create_back(int num) {       //\\//\\ Функ-я для создания списка //\\//\\ 
	int a = 1;     //Счеткик элементов
	char d;     //Переменная для ввода
	for (int i = 0; i < num; i++) {
		cout << "Введите данные для " << a++ << " позиции элемента deque -> ";
		cin >> d;
		push_back(d);    //Переход в функ-ю добавления элементов в конец списка
	}
	a = 0;
	system("cls");
}

void deque::push_front(char a)           //\\//\\ Функ-я внесения данных в очередь с начало //\\//\\ 
{
	obj* temp = new obj;               //Создали указатель
	temp->data = a;                   //Данные переносим в data
	if (left == NULL) {              //Если начало
		left = right = temp;        //То является и началом и концом
	}
	else {                        //Если еще данные присутствуют в очереди
		temp->next = left;       //Следующем элементом будет начало (Лево)
		left->prev = temp;      //Начало перемещаем на прошлое значение
		left = temp;           //Присваиваваем значение
	}
}

void deque::push_back(char a)        //\\//\\ Функ-я внесения данных в очередь с начало //\\//\\ 
{
	obj* temp = new obj;              //Создали указатель
	temp->data = a;                  //Данные переносим в data
	if (!left) {                    //Если начало
		left = temp;
		right = left;             //То является и началом и концом
	}
	else {                      //Если еще данные присутствуют в очереди
		right->next = temp;    //Следующем элементом будет конец (Справо)
		temp->prev = right;   //Конец перемещаем на прошлое значение
		right = temp;        //Присваиваваем значение
	}
	temp->next = NULL;     //Очистка указателя
	temp->prev = NULL;    //Очистка указателя
}

void deque::show()             //\\//\\ Функ-я для вывода стека //\\//\\ 
{
	obj* temp = left;                 //Создали указатель и поставили с начала
	cout << "Двусторонняя очередь (deque): ";
	while (temp) {                    //Цикл пока не закончатся данные
		cout << temp->data << " ";   //Выводим через пробел
		temp = temp->next;          //Переводим указатель на следующий элемент
	}
	cout << endl;
	cout << "\nДля продолжения нажмите любую клавишу...";
	_getch();
}

int deque::count()           //\\//\\ Функ-я для подсчета кол-ва элементов в очереди //\\//\\ 
{
	int count = 0;                    //Переменная для подсчитывания количества
	obj* temp = left;                //Указатель на начало
	while (temp) {                  //Цикл будет работать пока есть данные
		count++;                   //Накапливаем количество
		temp = temp->next;        //Переход к следующему значению
	}
	return count;               //Возвращаем данные
}

void deque::check_pull_6_elem() {           //\\//\\ Функ-я для проверки правильности вывода 6-го элемента очереди //\\//\\ 
	if ('1' == pull_6_elem()) {
		cout << "Элементов в очереди < 6, вывести результат не возможно!" << endl << endl;
		cout << "\nДля продолжения нажмите любую клавишу...";
		_getch();
	}
	else {
		cout << "Результат: " << pull_6_elem() << endl << endl;
		show();                                 //Функ-я вывода
		_getch();
	}

}

char deque::pull_6_elem() {       //\\//\\ Функ-я вывода 6-го элемента очереди //\\//\\ 
	char check;                                //Переменная для проверки
	obj* temp = left;                         //Ставим на начало
	if (count() >= 6) {                      //Проверка, если больше или равно 6
		for (int i = 0; i < 5; i++)         //Цикл до 5 элемента
			temp = temp->next;             //Переход на следующее значение
		return temp->data;                //Возвращаем значение
	}
	else {                              //Если значений меньше 6
		check = '1';
		return check;
	}
	return 0;
}

char deque::pull_last_elem() {       //\\//\\ Функ-я вывода последнего элемента очереди //\\//\\ 
	return right->data;          //Возврат элемента с конца (Справа)
}

void deque::saveInFile() {           //\\//\\ Функ-я записи в файл //\\//\\

	obj* temp = left;

	fstream f("Deque.txt", ios::out);        //Создали переменную для работы с файлом, создали файл.
	if (!f.is_open())                           //Проверка на открытие файла
		cout << "Ошибка! Файл не найден!";
	else {
		while (temp) {                       //Цикл пока не дойдем до конца
			f << temp->data << '\t';        //Запись данных списка в файл
			temp = temp->next;             //Шаг вперед
		}
	}

}

void deque::form_the_file() {                   //\\//\\ Функ-я чтения с файла //\\//\\ 

	char a;
	fstream f("Deque.txt", ios::in);   //Переменная для работы с файлом, открыли файл
	if (!f.is_open())                     //Проверка на открытие файла
		cout << "Ошибка! Файл не найден!";
	else {
		while (f >> a) {
			if (a != ' ')
				push_back(a);               //Обрашаемся к функ-ии
		}
	}
	f.close();                 //Закрыли файл

}