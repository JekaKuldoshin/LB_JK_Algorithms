#include "list.h"

bool queue::check() {        //\\//\\ Функ-я проверки на наличие элементов очереди //\\//\\ 
	if (first == NULL) {        //Если пуст стек, то выводим...
		system("cls");
		cout << "Ошибка! Очередь отсутствует!!!\n\nНажмите на Enter чтобы продолжить...";
		_getch();
		return false;
	}
	else
		return true;     //Если возврашает True, то мы можем пользоваться всем функционалом программы
}

void queue::create(int num) {       //\\//\\ Функ-я для создания списка //\\//\\ 
	int a = 1;     //Счеткик элементов
	char d;     //Переменная для ввода
	for (int i = 0; i < num; i++) {
		cout << "Введите данные для " << a++ << " позиции элемента стека -> ";
		cin >> d;
		Add(d);    //Переход в функ-ю добавления элементов в конец списка
	}
	a = 0;
	system("cls");
}

void queue::Add(char a) {
    obj* temp = new obj;             //Создаем указатель
    temp->data = a;                 //Данные переносим в data
    if (!first) {                  //Если не первый элемент
        first = temp;             //Передаем данные на первое место
        tail = first;            //Соединили
    }
    else {                     //Если уже были данные в очереди
        tail->prev = temp;    //В конец записываем данные
        tail = temp;         //Данные в конце
    }
    temp->prev = NULL;     //Очистили переменную
}

void queue::show()             //\\//\\ Функ-я для вывода стека //\\//\\ 
{
	obj* temp = first;                  //Создали указатель и поставили с начала
	cout << "Очередь: ";
	while (temp) {                    //Цикл пока не закончатся данные
		cout << temp->data << " ";   //Выводим через пробел
		temp = temp->prev;          //Переводим указатель на следующий элемент
	}
	cout << endl;
	cout << "\nДля продолжения нажмите любую клавишу...";
	_getch();
}

int queue::count()            //\\//\\ Функ-я подсчета кол-ва элементов в очереди //\\//\\ 
{
	int count = 0;             //Переменная для подсчета кол-ва
	obj* temp = first;        //Указатель на начало
	while (temp) {           //Цикл пока не закончатся данные
		count++;            //+1
		temp = temp->prev; //Перевод указателя на следуюший элемент
	}
	return count;        //Возвращаем значение
}

double queue::average()     //\\//\\ Функ-я для нахождения среднего ариметического //\\//\\ 
{
	char avarage = ' ';                  
	obj* temp = first;                 //Указатель на начало очереди
	while (temp) {                    //Цикл пока не закончатся данные
		avarage += temp->data;       //Накопление переменной
		temp = temp->prev;          //Переход на следуюший элемент
	}
	return avarage / count();     //При возврашении делим на кол-во для нахождение среднего арифметического
}

char queue::Max()                  //\\//\\ Функ-я для нахождения Макс. //\\//\\ 
{
	char max = first->data;              //Изночально ставим первый элемент как максимальный
	obj* temp = first->prev;            //Переводим на следуюший элемент для дальнейшего сравнения
	while (temp) {                     //Цикл пока не закончатся данные
		if (max < temp->data)         //Если Макс < елемента, меняем
			max = temp->data;        //Присвоение
		temp = temp->prev;          //Переход к следуюшему елементу
	}

	return max;                  //Возвращаем переменную
}

char queue::Min()            //\\//\\ Функ-я для нахождения минимального элемента //\\//\\ 
{
	char min = first->data;          //Изночально ставим первый элемент как мин.
	obj* temp = first->prev;        //Переводим на следуюший элемент для дальнейшего сравнения
	while (temp) {                 //Цикл пока не закончатся данные
		if (min > temp->data)     //Если Мин > елемента, меняем
			min = temp->data;    //Присвоение
		temp = temp->prev;      //Переход к следуюшему елементу
	}

	return min;              //Возвращаем переменную
}

char queue::prevMin()            //\\//\\ Функ-я для нахождения элемента который стоит после минимального //\\//\\ 
{
	char prevMin;                          //Переменная
	obj* temp = first;                    //Указатель на начало
	if (Min() == first->data)            //Если минимальное число является началом, тогда просто выводим Минимальный элемент
		return Min();                   //Возвращаем переменную
	while (temp) {                              //Цикл пока не закончатся данные

		if (temp->prev->data == Min())         //Если приравнивается у минимуму, делаем шаг назад и -> 
			return temp->data;                //Возвращаем переменную
		temp = temp->prev;                   //ШАГ ВПЕРЕД для цикла
	}

}

void queue::saveInFile() {           //\\//\\ Функ-я записи в файл //\\//\\

	obj* temp = first;

	fstream f("Queue.txt", ios::out);        //Создали переменную для работы с файлом, создали файл.
	if (!f.is_open())                           //Проверка на открытие файла
		cout << "Ошибка! Файл не найден!";
	else {
		while (temp) {                       //Цикл пока не дойдем до конца
			f << temp->data << '\t';        //Запись данных списка в файл
			temp = temp->prev;             //Шаг вперед
		}
	}

}

void queue::form_the_file() {                   //\\//\\ Функ-я чтения с файла //\\//\\ 

	char a;
	fstream f("Queue.txt", ios::in);   //Переменная для работы с файлом, открыли файл
	if (!f.is_open())                     //Проверка на открытие файла
		cout << "Ошибка! Файл не найден!";
	else {
		while (f >> a) {
			if (a != ' ')
				Add(a);               //Обрашаемся к функ-ии
		}
	}
	f.close();                 //Закрыли файл

}